# 용어 및 변수명 컨벤션

모든 클래스 명은 대문자로 시작한다.

```javascript
class A {
	...
}
```

여러 개의 원소를 포함할 수 있는 집합(ex: 배열, 맵, 트라이 등)의 레퍼런스는 반드시 s를 붙인다.

```javascript
class Foo {
    ...
}

class Bar {
	constructor() {
        this.root = new Foo();
        this.childs = [];
    }
}
```

이는 변수명 뿐만 아니라 문서에서 대상을 지칭할 때에도 동일하게 적용한다.

문서에서 어떤 클래스/집합에 속한 임의의 엔티티를 표현할 때는 `[[ClassName]]`을 사용한다.



# 스프(Soup)

**스프**(`Soup`)는 **지식**으로 구성된 방향성 비순환 그래프(DAG)로, 기계적으로 문제를 만들 수 있는 자료구조다. 이름의 유래는 파이썬의 유명한 HTML 파싱 라이브러리 `Beautiful Soup`다.



## 지식(Info)

```pseudocode
define Info:
	String[]	names		// +, 이름
	String[]	attrs		// *, 속성
	String		comment		// 1, 주석
	Info[]		parents		// +, 직속상위지식
	Info[]		childs		// *, 직속하위지식
	Object		ext			// 1, 기타 추가 정보
```

**지식**(`Info`)는 다음과 같은 것들을 모델링하는데 사용한다.

- **과목**(Subject): 자신이 공부하고자하는 과목에 대한 데이터의 모음.
- **태그**(Tag): 자신이 필기한 내용을 부연설명하는 요소
- **폴더**(Folder): 여러 연관성 있는 지식들을 하나로 묶음

어떤 **지식** A에서 B로 유한 번의 참조로 도달할 수 있을 때, B는 A의 **하위지식**(`subinfo`), A는 B의 **상위지식**(`superinfo`)라고 한다.

임의의 **지식** G에 대하여, G는 자신의 어떤 하위지식에도 소속되어선 안된다. 즉, 그래프 상에서 순환이 발생해서는 안된다. 어떤 지식과 그 지식의 이름, 속성에 대하여 명제 *"[[이름]]은/는 [[속성]]이다"*는 참이어야 한다.

상위지식의 속성은 하위지식에서도 참이어야 한다.



# 필기(Doc)

```pseudocode
define Doc:
	String	content	// 1, 필기의 내용
	Group[]	soups	// +, 이 필기가 만들어낸 수프의 최상단 주제(들)
```

**필기**(`Doc`)는 서비스 이용자가 특정 과목 수업을 듣고 메모한 내용을 저장한 정보다. 추상적인 모델과 사용자를 연결해주는 인터페이스 역할을 한다.

**필기**는 추상적인 정보를 얻을 수 있는 원천이다. 계층적인 정보를 사용자에게 직접 입력받는 것(그래프의 노드를 직접 만드는 것)은 매우 좋지 못한 UX를 제공한다. 대신 여러 필기 어플리케이션이나 위키처럼 내용을 입력받고, 프로그램에서 이를 가공한다면 사용하기가 편리할 것이다.

**필기**가 만들어낸 **스프**는 내용이 수정될 경우 같이 연동되어야 한다.



### 내용(Content)

```markdown
# 소녀전선
우중아 이게 게임이냐
## 인형
### HG
초보자들은 종종 권총을 딜러로 착각하곤 한다.
### AR
* 제대에서 딜러 역할을 맡는다.
#### M4A1
* 주인공 소대 중 한 명이다.
* 시나몬롤 또는 혐포라고도 불린다.
* MOD2 개조시, 제대원이 3명 이하일 때 스킬을 사용하면 고화력 저사속 공격을 한다.
* 과거에는 성능이 좋지 않아서 인기가 없었지만 개편 이후 적폐 캐릭터가 되었다.
### SMG
```

**필기**의 **내용**(`content`)은 사용자가 편집한 내용을 저장하는 문자열이다.

**내용**은 마크다운(Markdown) 표준을 따른다. 그러나 사용자가 마크다운에서 제공하는 모든 기능을 사용할 필요는 없다. 본 서비스에서 집중적으로 활용하는 것은 구조를 표현하는 기능(`#`, `*`)이다. 하이퍼링크나 표, 이미지, 수식, 인용구 등의 부수적인 기능은 추후 필요에 따라 지원할 수 있다.

사용자로부터 안전한 입력을 받으려면 WYSIWYG[^1] 에디터를 제공해줘야 한다. WYSIWYG 방식의 편집기에서 구조를 나타내기 위해 사용하는 기호들(`#`, `*` 등)은 사용자에게 보이지 않는다. 블로그에 글을 쓰면 HTML로 저장되지만, 사용자가 고급 모드로 들어가지 않으면 안보이는 것과 같다. 또한 사용자들은 마크다운 문법을 굳이 알 필요가 없다.

[^1]: What You See Is What You Get. 데이터가 눈에 보이는대로 입력되는 것. 반대 개념은 LaTeX처럼 명령어 기반으로 문서를 편집하는 것이다.



# Doc와 Soup의 관계

모든 **필기**는 **스프**로 변환할 수 있다. 그러나 그 역은 성립하지 않는다. 2019년 7월 12일 기준으로 **필기**는 **스프**의 모든 것을 표현할 수 없다. 대표적인 예시가 **지식**의 이름으로, 2개 이상의 이름을 **필기**에 표현할 규칙이 없다.

**필기**와 수프는 1:1 대응이 아니다. 엄밀히, 본 서비스의 모든 데이터는 거대한 단일 스프로 이루어져 있다. 그 스프에서 특정 지식을 루트로 갖는 서브그래프가, 이용자가 다루게 될 부분이다.

이용자가 문서 작성/수정을 완료하면, 그 문서는 즉시 수프로 **조리**(`Cook`)한다. 여기에는 특별한 보안이 필요하지 않으므로, 조리 과정은 모두 클라이언트가 담당하도록 한다.



## 데이터 저장 방식

서버는 **필기**와 **수프**를 별도로 저장한다. 이유는 다음과 같다.

1. 문제 생성을 위해 필요한 **로직과, 이용자의 이해도가 일치하지 않기 때문**이다. 이용자는 어려운 그래프 구조를 이해하고, 귀찮게 노드를 만들고 싶어하지 않는다. 그저 수업을 듣고 필기한 내용을 가지고 자동으로 문제를 만들어주기를 바란다. (기본적으로 본 서비스는 이용자들이 매우 게으르다고 가정한다)
2. 상술했던 **문서-스프의 비가역성** 때문이다. 만약 서버에 스프만 저장한다면, 사용자가 처음 입력한 데이터와 실제 저장되는 데이터 간에 차이가 생긴다.
3. **모델과 뷰를 독립적으로 관리**하기 위함이다. 스프는 추상적인 모델, 문서는 구체적인 뷰로 볼 수 있다. 모델과 뷰를 분리하면, 이용자 로직과 서버 로직을 매우 유연하게 다룰 수 있다. 같은학교 학생이 만든 과목 문제를 풀고 싶은데 굳이 그 사람의 필기를 볼 필요는 없다. 서버는 문제 풀고 싶어하는 사용자에게 그 과목에 해당하는 스프만 보내주면 된다.



## 조리 알고리즘(Cooking Algorithm)

### 문서 전처리(Pre-processing)

문서를 수프로 만들기 위해, 다음과 같이 몇 가지 토큰을 정의한다.

* `<문장>`은 정규표현식 `/(문서시작|개행)(공백)*[^개행]*(개행)/`을 만족하는 문자열에서 모든 개행 문자, 맨 앞에 연속으로 나오는 공백문자들을 제거한 것이다.
* `<제목n식별자>`는 정규표현식 `/#{n} (.)*/`을 만족하는 `<문장>`이다.
* `<속성식별자>`는 정규표현식 `/\* (.)*/`을 만족하는 `<문장>`이다.

* `<제목n>`은 `<제목n식별자>`에서 `/#{n} /`을 제거한 것이다.
* `<속성>`은 `<속성식별자>`에서 `/\* /`을 제거한 것이다.
* `<소주석>`은 `<제목n식별자>`도 `<속성n식별자>`도 아닌 `<문장>`이다.
* `<주석>`은 2개의 `<소주석>` 또는 `<주석>`을 개행문자 1개로 연결한 것이다.



문서를 전처리하는 것은 위 방식대로 쪼갠 토큰을 다음과 같이 가공하는 것이다. (작업중... 의사코드로 만들자)

1. 가장 마지막 토큰부터 처리한다.
2. 현재 토큰이 `<소주석>` 또는 `<주석>`이고, 앞 토큰이 `<소주석>` 또는 `<주석>` 이면 둘을 합쳐 `<주석>`으로 만든다. 그렇지 않다면, 앞 토큰이 `<소주석>`  또는 `<주석>` 또는 `<제목n식별자>`가 될 때까지 현재 토큰과 자리를 바꾼다.
3. 현재 토큰이 `<소주석>` 또는 `<주석>`이고, 앞 토큰이 없으면, 현재 토큰은 삭제한다.
4. 더이상 읽을 토큰이 없을 때까지 2~3을 반복한다.
5. 모든 `<제목n식별자>`는 `<제목n>`이 되도록 일부 문자를 삭제한다.
6. 모든 `<속성식별자>`는 `<속성>`이 되도록 일부 문자를 삭제한다.

토큰의 수가 n이면 시간복잡도는 O(n)이 된다. 이렇게 처리한 문서는 제목-주석-속성 구조를 갖게 된다.



예시를 참고하기 바란다.

```
* 이건 속성이 아님 왜냐면 문서 처음이기 때문이지
#### 첫 제목이 꼭 제목1일 필요는 없다
     * 이렇게 쓰면 * 앞에 있는 공백은 다 무시함
  ** 2개를 붙일 경우 아무것도 아니라서 주석처리됨
* 제목이나 속성     을 여러 줄로
분리하는 것은 허용하지 않는다.
왜냐하면 속성은 최대한 간결하게 작성하기를 바라기 때문이다.
# 큰제목
주석1
* 속성1
주석2
## 작은제목
```



위 문서를 전처리하면 다음과 같다. 제일 왼쪽의 괄호는 토큰 종류를 보여주기 위함으로 문자열에 포함돼 있지 않다.

```
(제목4) 첫 제목이 꼭 제목1일 필요는 없다
(주 석) ** 2개를 붙일 경우 아무것도 아니라서 주석처리됨
       분리하는 것은 허용하지 않는다.
       왜냐하면 속성은 최대한 간결하게 작성하기를 바라기 때문이다.
(속 성) 이렇게 쓰면 * 앞에 있는 공백은 다 무시함
(속 성) 제목이나 속성     을 여러 줄로
(제목1) 큰제목
(주 석) 주석1
       주석2
(속 성) 속성1
(제목2) ## 작은제목
```



### 추상화

전처리를 마친 문서는 다음 과정을 거쳐 수프로 만든다.

* 현재 토큰이 `<제목n>`이면 그것을 `name`으로 갖는 **지식** G를 만든다.
* `<제목n>` 아래에 `<제목m>`이 있으면, 자식을 만들어서 G에 붙인다.
* 지식도 자식주제도 없는 **지식**은 폐기처리한다.
* 이를 재귀적으로 반복한다.

자세한 의사코드는 다음과 같다. 음.... 당신이 이거 담당자가 아니라면 안읽는걸 추천한다.

```pseudocode
function cook(tokens):
	let out := [] be the forest of soup
	suppose i[0], i[1] ... be decreasing sequence of depth of <제목n> tokens
	foreach j := 0, 1, ...:
		out += assemble(tokens, i[j], i[j + 1]) if its result is not NULL
	return out

// tokens[spos] must be title-n
function assemble(tokens, spos, epos):
	let out := new Info(names=[tokens[spos]], attrs=[])
	spos := spos + 1
	while spos < epos:
		if tokens[spos] is <comment>:
		// 현재 토큰이 <주석>인 경우
			out.comment := tokens[spos]
			spos := spos + 1
		else if tokens[spos] is <attribute>:
		// 현재 토큰이 <속성>인 경우
			out.attrs := attrs + tokens[spos]
			spos := spos + 1
		else:
		// 현재 토큰이 <제목n>인 경우, 다른 <제목n>을 찾아서 그 직전까지 자른다.
            do:
                suppose tokens[spos] is <title-n>
                let idx be the integer s.t. 
                	spos < idx < epos and depth of tokens[idx] <= depth of token
                if such idx not exists:
                	idx := epos
                result := assemble(tokens, spos, idx)
                append result to out if result is not NULL
                spos := idx
            while spos < epos:
	end while:
	
	if out has at least one attribute or child:
		reutrn out
	else:
	// 지식도 없고 자식주제도 없으면 이 주제는 의미가 없다.
		return NULL
```


