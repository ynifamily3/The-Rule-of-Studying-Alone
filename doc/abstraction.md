# 용어 및 변수명 컨벤션

모든 클래스 명은 대문자로 시작한다.

```javascript
class A {
	...
}
```

여러 개의 원소를 포함할 수 있는 집합(ex: 배열, 맵, 트라이 등)의 레퍼런스는 반드시 s를 붙인다.

```javascript
class Foo {
    ...
}

class Bar {
	constructor() {
        this.root = new Foo();
        this.childs = [];
    }
}
```

이는 변수명 뿐만 아니라 문서에서 대상을 지칭할 때에도 동일하게 적용한다.

문서에서 어떤 클래스/집합에 속한 임의의 엔티티를 표현할 때는 `[[ClassName]]`을 사용한다.



# 문서(Doc)

```markdown
# 소녀전선
우중아 이게 게임이냐
## 인형
### HG
초보자들은 종종 권총을 딜러로 착각하곤 한다.
### AR
* 제대에서 딜러 역할을 맡는다.
#### M4A1
* 주인공 소대 중 한 명이다.
* 시나몬롤 또는 혐포라고도 불린다.
* MOD2 개조시, 제대원이 3명 이하일 때 스킬을 사용하면 고화력 저사속 공격을 한다.
* 과거에는 성능이 좋지 않아서 인기가 없었지만 개편 이후 적폐 캐릭터가 되었다.
### SMG
```

**문서**(`Doc`)는 서비스 이용자가 특정 과목 수업을 듣고 필기한 내용을 계층적으로 저장한 정보다.

문서는 **마크다운 표준**을 기본으로 하되, 표준의 모든 기능을 지원하지는 않는다. 본 서비스에서 집중적으로 활용하는 것은 정보의 계층을 표현할 수 있는 기능(`#`, `#`, ..., `*`)이다. 하이퍼링크나 표, 이미지, 수식, 인용구 등의 부수적인 기능은 추후 필요에 따라 지원할 수 있다.

문서에 사용되는 많은 기호들(#, * 등)은 기본적으로 서비스 이용자들에게 보이지 않는다. 마치 블로그에 쓰는 글이 사실은 HTML이지만, 고급 모드로 들어가지 않으면 안보이는 것과 같다. 대신, 에버노트나 블로그 글쓰기 기능처럼 간단한 편집기를 제공해준다. 그러면 이용자들이 마크다운 문법을 굳이 배울 필요가 없어진다.

문서 편집기는 Typora처럼 생기면 된다. 기본적인 버튼(제목1, 제목2, 제목3, 제목4, 제목5, 제목6, 항목)을 제공하자.



# 수프(Soup)

**수프**(`Soup`)는 주제와 지식으로 구성된 방향성 비순환 그래프(DAG)로, 기계적으로 문제를 만들 수 있는 자료구조다.

수프라는 이름은 파이썬의 유명한 HTML 파싱 라이브러리 `Beautiful Soup`에서 가져왔다.



## 주제(Group)

```pseudocode
define Group:
	String	name		// 1, 이름
	Group[]	childgroups	// *, 자식주제
	Info[]	infos		// *, 지식
	String	comment		// 1, 주석
	Object	ext			// 1, 문제 만들기와 관계없는, 서비스단을 위한 정보(ex: 학교)
```

**주제**(`Group`)는 다음과 같은 것들을 표현하는데 사용한다.

* 과목(Subject): 자신이 공부하고자하는 과목에 대한 데이터의 모음.
* 태그(Tag): 자신이 필기한 내용
* 폴더(Folder)

어떤 주제 A에서 B로 유한 번의 참조로 도달할 수 있을 때, B는 A의 **하위주제**(`subgroups`), A는 B의 **상위주제**(`supergroup`)라고 한다.

어떤 주제로부터 유한 번의 참조를 통해 도달할 수 있는 지식을, 그 주제의 **하위지식**(`subinfos`)이라 한다.

임의의 주제 G에 대하여, G는 자신의 어떤 하위주제에도 소속되어선 안된다. 즉, 그래프 상에서 순환이 발생해서는 안된다.`child`가 들어가서 마치 트리처럼 보일 수도 있지만, 하나의 주제는 여러 주제의 자식주제가 될 수 있기 때문에 트리가 아닌 **DAG**(Directed Acylic Graph)를 형성한다.



## 지식(Info)

```pseudocode
define Info:
	String[]	names
	String[]	attrs
	Group[]		basegroups
	Object		ext
```

**지식**(`Info`)은 1개 이상의 **이름**(`names`)과 1개 이상의 **속성**(`attrs`), 1개 이상의 **소속주제**(`basegroups`)으로 이루어진 단위 구조이다. 어떤 지식과 그 지식의 이름, 속성에 대하여 명제 *"[[이름]]은/는 [[속성]]이다"*는 참이어야 한다.



# 문서와 수프의 관계

모든 문서는 스프로 변환할 수 있다. 그러나 그 역은 성립하지 않는다. 2019년 7월 12일 기준으로 문서는 스프의 모든 것을 표현할 수 없다. 대표적인 예시가 `지식`의 이름으로, 2개 이상의 이름을 문서에 표현할 규칙이 없다.

문서와 수프는 1:1 대응이 아니다. 엄밀히, 본 서비스의 모든 데이터는 거대한 단일 스프로 이루어져 있다. 그 스프에서 특정 주제(or 과목)를 루트로 갖는 서브그래프가, 이용자가 다루게 될 부분이다.

이용자가 문서 작성/수정을 완료하면, 그 문서는 즉시 수프로 **조리**(`Cook`)한다. 여기에는 특별한 보안이 필요하지 않으므로, 조리 과정은 모두 클라이언트가 담당하도록 한다.



## 조리 알고리즘(Cooking Algorithm)

### 문서 전처리(Pre-processing)

문서를 수프로 만들기 위해, 다음과 같이 몇 가지 토큰을 정의한다.

* `<문장>`은 정규표현식 `/(문서시작|개행)(공백)*[^개행]*(개행)/`을 만족하는 문자열에서 모든 개행 문자, 맨 앞에 연속으로 나오는 공백문자들을 제거한 것이다.
* `<제목n식별자>`는 정규표현식 `/#{n} (.)*/`을 만족하는 `<문장>`이다.
* `<속성식별자>`는 정규표현식 `/\* (.)*/`을 만족하는 `<문장>`이다.

* `<제목n>`은 `<제목n식별자>`에서 `/#{n} /`을 제거한 것이다.
* `<속성>`은 `<속성식별자>`에서 `/\* /`을 제거한 것이다.
* `<소주석>`은 `<제목n식별자>`도 `<속성n식별자>`도 아닌 `<문장>`이다.
* `<주석>`은 2개의 `<소주석>` 또는 `<주석>`을 개행문자 1개로 연결한 것이다.



문서를 전처리하는 것은 위 방식대로 쪼갠 토큰을 다음과 같이 가공하는 것이다. (작업중... 의사코드로 만들자)

1. 가장 마지막 토큰부터 처리한다.
2. 현재 토큰이 `<소주석>` 또는 `<주석>`이고, 앞 토큰이 `<소주석>` 또는 `<주석>` 이면 둘을 합쳐 `<주석>`으로 만든다. 그렇지 않다면, 앞 토큰이 `<소주석>`  또는 `<주석>` 또는 `<제목n식별자>`가 될 때까지 현재 토큰과 자리를 바꾼다.
3. 현재 토큰이 `<소주석>` 또는 `<주석>`이고, 앞 토큰이 없으면, 현재 토큰은 삭제한다.
4. 더이상 읽을 토큰이 없을 때까지 2~3을 반복한다.
5. 모든 `<제목n식별자>`는 `<제목n>`이 되도록 일부 문자를 삭제한다.
6. 모든 `<속성식별자>`는 `<속성>`이 되도록 일부 문자를 삭제한다.

토큰의 수가 n이면 시간복잡도는 O(n)이 된다. 이렇게 처리한 문서는 제목-주석-속성 구조를 갖게 된다.



예시를 참고하기 바란다.

```
* 이건 속성이 아님 왜냐면 문서 처음이기 때문이지
#### 첫 제목이 꼭 제목1일 필요는 없다
     * 이렇게 쓰면 * 앞에 있는 공백은 다 무시함
  ** 2개를 붙일 경우 아무것도 아니라서 주석처리됨
* 제목이나 속성     을 여러 줄로
분리하는 것은 허용하지 않는다.
왜냐하면 속성은 최대한 간결하게 작성하기를 바라기 때문이다.
# 큰제목
주석1
* 속성1
주석2
## 작은제목
```



위 문서를 전처리하면 다음과 같다. 제일 왼쪽의 괄호는 토큰 종류를 보여주기 위함으로 문자열에 포함돼 있지 않다.

```
(제목4) 첫 제목이 꼭 제목1일 필요는 없다
(주 석) ** 2개를 붙일 경우 아무것도 아니라서 주석처리됨
       분리하는 것은 허용하지 않는다.
       왜냐하면 속성은 최대한 간결하게 작성하기를 바라기 때문이다.
(속 성) 이렇게 쓰면 * 앞에 있는 공백은 다 무시함
(속 성) 제목이나 속성     을 여러 줄로
(제목1) 큰제목
(주 석) 주석1
       주석2
(속 성) 속성1
(제목2) ## 작은제목
```



### 추상화

전처리를 마친 문서는 다음 과정을 거쳐 수프로 만든다.

* 현재 토큰이 `<제목n>`이면 그것을 `name`으로 갖는 *주제* G를 만든다.
* `<제목n>` 아래에 `<속성>`이 하나라도 있으면, 같은 이름을 갖는 *지식* I를 만들고 G에 붙인다.
* `<제목n>` 아래에 `<제목m>`이 있으면, 자식을 만들어서 G에 붙인다.
* 지식도 자식주제도 없는 주제는 폐기처리한다.
* 이를 재귀적으로 반복한다.

자세한 의사코드는 다음과 같다. 음.... 당신이 이거 담당자가 아니라면 안읽는걸 추천한다.

```pseudocode
function cook(tokens):
	let out := [] be the forest of soup
	suppose i[0], i[1] ... be decreasing sequence of depth of <제목n> tokens
	foreach j := 0, 1, ...:
		out += assemble(tokens, i[j], i[j + 1]) if its result is not NULL
	return out

// tokens[spos] must be title-n
function assemble(tokens, spos, epos):
	let out := new Group(name=tokens[spos])
	let attrs := []
	spos := spos + 1
	while spos < epos:
		if tokens[spos] is <comment>:
		// 현재 토큰이 <주석>인 경우
			out.comment := tokens[spos]
			spos := spos + 1
		else if tokens[spos] is <attribute>:
		// 현재 토큰이 <속성>인 경우
			attrs := attrs + tokens[spos]
			spos := spos + 1
		else:
		// 현재 토큰이 <제목n>인 경우, 다른 <제목n>을 찾아서 그 직전까지 자른다.
            do:
                suppose tokens[spos] is <title-n>
                let idx be the integer s.t. 
                	spos < idx < epos and depth of tokens[idx] <= depth of token
                if such idx not exists:
                	idx := epos
                out.childgroups += assemble(tokens, spos, idx) if its result is not NULL
                spos := idx
            while spos < epos:
	end while:
	
	if attrs.length > 0:
	// 속성이 하나라도 있으면 그 주제와 같은 이름의 지식을 만든다.
		out.infos += new Info(names=[out.name], attrs=attrs)
		return out
	else if out.childgroups.length > 0:
	// 자식주제가 하나라도 있으면 그냥 중간 주제로서 반환한다.
		return out
	else:
	// 지식도 없고 자식주제도 없으면 이 주제는 의미가 없다.
		return NULL
```



## 데이터 저장 방식

서버는 문서와 수프를 별도로 저장한다. 이유는 다음과 같다.

1. 문제 생성을 위해 필요한 **로직과, 이용자의 이해도가 일치하지 않기 때문**이다. 이용자는 어려운 그래프 구조를 이해하고, 귀찮게 노드를 만들고 싶어하지 않는다. 그저 수업을 듣고 필기한 내용을 가지고 자동으로 문제를 만들어주기를 바란다. (기본적으로 본 서비스는 이용자들이 매우 게으르다고 가정한다)

2. 상술했던 **문서-수프의 비가역성** 때문이다. 만약 서버에 수프만 저장한다면, 사용자가 처음 입력한 데이터와 실제 저장되는 데이터 간에 차이가 생긴다.

3. **모델과 뷰를 독립적으로 관리**하기 위함이다. 수프는 추상적인 모델, 문서는 구체적인 뷰로 볼 수 있다. 모델과 뷰를 분리하면, 이용자 로직과 서버 로직을 매우 유연하게 다룰 수 있다. 같은학교 학생이 만든 과목 문제를 풀고 싶은데 굳이 그 사람의 필기를 볼 필요는 없다. 서버는 문제 풀고 싶어하는 사용자에게 그 과목에 해당하는 수프만 보내주면 된다.



# 문제(Quest)

문제(`Quest`)는 1개의 **유형**(`type`), 1개의 **지문**(`statement`), 1개 이상의 **선택지**(`choices`), 1개 이상의 **정답**(`answers`)로 이루어진 단위 구조이다.

* **참/거짓**(`"binary"`): `choices`는 불리언의 집합 {true, false}가 된다.
* **n지선다**(`"selection"`): `choices`는 $\mathcal{P}(\{1, 2, 3, \cdots, n\})$이다. 악랄한 문제의 경우, 주어진 어떤 선택지도 답이 아닐 수 있다. 이 경우 `answers`는 공집합이 된다.
* **단답형**(`"short"`): 선택지는 문자열의 집합 전체다. 이렇게 무한한 선택지를 갖는 경우, `choices`는 `null`로 정의한다.



# 알고리즘

## 하위지식 가져오기

평범한 DFS를 쓰면 된다. 전위탐색을 사용할 경우 주어진 주제로부터 가까운 지식이 리스트의 앞으로 오게 된다. 아래의 의사코드는 전위탐색으로 `g`의 하위지식을 `I`에 저장한다.

```pseudocode
Let I := Φ be the set of subinfos
function fetch_subinfos(Group g):
	foreach i in infos of g:
		if i is not visted:
			I := I ∪ {i}
	foreach cg in childgroups of g:
		if cg is not visted:
			fetch_subinfos(cg)
	return I
```

구현 시 중복체크를 용이하게 하기 위해 `Group`과 `Info`에 정수 ID를 기록해두고, 해시셋으로 중복여부를 관리하는 것이 좋다.



## 참/거짓 문제 생성

주어진 지식 `i`로 참/거짓 고르기 문제를 만든다. 만약 지문에 사용할 속성을 다른 지식에서 가져올 경우, 그 속성이 `i`의 속성 중 일부와 동치여서는 안된다. 만약 `i`의 속성을 변조할 경우, 확실하게 거짓임이 보장되는 형태로 변조해야 한다.

두 속성이 서로 동치인지 정확히 구분하는 것은 매우 어렵다. 하지만 문장의 의미는 잠시 내려두고, 문장을 이루는 단어의 구성이나 생김새로 유사 여부를 판단할 수는 있다. 만약 높은 유사성을 보인다면 그 속성은 버리면 선택하지 않으면 된다.

```
속성 a: 회피가 매우 높은 SMG이다.
속성 b: SMG 중 회피가 높은 편이다.
속성 c: SMG에서 체력이 높다.
속성 d: 귀여운 샷건이다.
```

속성 a, b가 문자열 `SMG`, `회피`, `높은`을 공유하는 반면 a, c는 `SMG`, `높`만 공유하며 a, d는 아무것도 공유하지 않는다. (사실 단어 높과 높은은 같은 뜻이지만, 이걸 구분하는 건 NLP의 영역이다) 아주 짧은 문장에서 3개가 겹칠 정도면 꽤 유사하다고 볼 수 있다. 2개가 겹치는 경우 확실하게 겹치는 건진 몰라도, 일단 선택지에서 제외하면 안전할 것이다.



변조를 구현하는 것은 자연어 처리의 영역이기 때문에, 본 프로젝트에서 적용 여부는 확실하지 않다. 다음과 같이 특수한 경우에 대해서 고려해볼 수는 있다.

* 사건의 날짜를 나타내는 문자열의 일부를 다른 숫자로 바꾼다.
* ~~하다와 ~~하지않다를 서로 바꾼다.

또는 속성을 입력할 때 특수한 메타 정보를 삽입하는 방식도 생각해 볼 수 있다. 하지만 사용자 편의적으로는 상당히 귀찮아서, 버려진 기능이 될 가능성이 크다.

```pseudocode
Let ans be the unique answer of this quest
Let fact be the proposition of this binary quest
function generate_binary_quest(Info i):
	// 50%의 확률로 참인 명제를 고른다 
	Select r ~ [0, 1]
	if r > 0.5:
		ans := true
		fact := select_positive(i)
	else:
		ans := false
		// 50%의 확률로 다른 지식의 속성을 가져오며
		// 나머지 50%의 확률로 기존의 속성을 변조한다
		r ~ [0, 1]
		if r > 0.5:
			fact := select_negative(i)
		else:
			fact := mutate_attr(select_positive(i))
	return {
		statement: "다음 문장의 참 거짓을 판별하시오.\n" + ,
		type: "binary",
		choices: [true, false],
		answers: [ans]
	}
	
// 지식 i에서 올바른 속성을 선택한다.
function select_positive(Info i):
	Select attr ~ i.attrs
	return attr

// 지식 i의 소속주제에서 다른 주제의 속성을 선택한다.
function select_negative(Info i):
	Let H := {h ∈ S.infos : S ∈ i.homegroups}
	Let F := {h ∈ H : ∀a∈i.attrs ￢(h ≡ a)}
	Select attr ~ F
	return attr
```

